## 문제 (특정 거리의 도시 찾기)

어떤 나라에는 1번부터 *N*번까지의 도시와 *M*개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.

이 때 특정한 도시 *X*로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 *K*인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 *X*에서 출발 도시 *X*로 가는 최단 거리는 항상 0이라고 가정한다.

예를 들어 *N*=4, *K*=2, *X*=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.

[https://upload.acmicpc.net/a5e311d7-7ce4-4638-88a5-3665fb4459e5/-/preview/](https://upload.acmicpc.net/a5e311d7-7ce4-4638-88a5-3665fb4459e5/-/preview/)

이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다.  2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.

## 입력

첫째 줄에 도시의 개수 *N*, 도로의 개수 *M*, 거리 정보 *K*, 출발 도시의 번호 *X*가 주어진다. (2 ≤ *N* ≤ 300,000, 1 ≤ *M* ≤ 1,000,000, 1 ≤ *K* ≤ 300,000, 1 ≤ *X* ≤ *N*) 둘째 줄부터 *M*개의 줄에 걸쳐서 두 개의 자연수 *A*, *B*가 공백을 기준으로 구분되어 주어진다. 이는 *A*번 도시에서 *B*번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ *A*, *B* ≤ *N*) 단, *A*와 *B*는 서로 다른 자연수이다.

## 출력

*X*로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 *K*인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.

이 때 도달할 수 있는 도시 중에서, 최단 거리가 *K*인 도시가 하나도 존재하지 않으면 -1을 출력한다.

## 예제 입력 1

```
4 4 2 1
1 2
1 3
2 3
2 4
```

## 예제 출력 1

```
4
```

## 첫 번째 풀이

```python
N, M, K, X = map(int, input().split())

# 도로 연결정보를 저장할 리스트
roads = [0 for i in range(N+1)]

# 도로 연결정보 입력받기
for i in range(M):
  start, end = map(int, input().split())

  new_val = roads[start] + 1

  # 가장 짧은 거리인지 판단하며 도로 거리정보 업데이트
  if roads[end] == 0 or roads[end] > new_val:
    roads[end] = new_val
  else:
    pass

if K in roads:
  for i in range(1, N+1):
    if roads[i] == K:
      print(i)
else:
  print(-1)
```

- 위 코드의 **시간복잡도는 O(N+M)**이다
- 우선 도시간 도달하는 도로의 최소 거리를 저장할 배열을 생성한다
- 그리고 도로 연결정보를 입력받으면서, 최소 거리를 저장한다
- 모든 최소거리를 저장하였다면, for문을 돌면서 지정된 거리 정보를 가진 도시 번호를 출력한다.
- **하지만 예제 테스트케이스에서는 잘 동작한 반면에, 백준에 제출한 결과, 시간 초과가 떴다..!**

## 두 번째 풀이

```python
N, M, K, X = map(int, input().split())

# 도로 연결정보를 저장할 리스트
roads = [-1 for i in range(N+1)]
roads[X] = 0

# 도로 연결정보 입력받기
for i in range(M):
  start, end = map(int, input().split())

  new_val = roads[start] + 1

  # 가장 짧은 거리인지 판단하며 도로 거리정보 업데이트
  if roads[end] == -1 or roads[end] > new_val:
    roads[end] = new_val
  else:
    pass

if K in roads:
  while K in roads:
    idx = roads.index(K)
    print(idx)
    roads[idx] = -1
else:
  print(-1)
```

- 위 코드의 **시간복잡도는 (N+num_of_answer)**이다
- 첫 번째 코드에서 도시의 개수만큼 for문을 돌며 값을 체크한 것이 영향을 미친 것일까 싶어서 해당 부분을 수정하였다
- while문을 통해 찾고자하는 값이 있을때만 index() 함수를 사용하여 그 위치 인덱스 정보를 바로 반환하도록 하였다
→ 이 부분에서 최대 O(M)에서 정답의 개수만큼만 for문을 돌도록 개선하였다
- 또한 시작 도시를 명확하게 하고자, 도로 정보 초기화 값을 0이 아닌 -1로 변경하였다.
- **하지만 이 코드도 예제 테스트케이스에서는 잘 동작한 반면에, 백준에 제출한 결과 또 시간 초과가 떴다..!
(언어의 문제일까 싶어 pypy3로 해보았지만, 이번에는 출력초과가 떴다 ,, 😭)**

## 내가 한 실수 (**찾았다 반례..! 순서가 중요함!!)**

```
# 교재에 게시된 예시 테스트 케이스
4 4 2 1
1 2
1 3
2 3
2 4
```

```
# 통과하지 못한 테스트 케이스
4 4 2 1
1 3
2 4
2 3
1 2
```

- 얼핏 보면 교재에 게시된 예시 테스트 케이스들과 비슷해보인다! 하지만 들어오는 순서가 다르다!!!
- 하지만 **순서가 다르다고 해서 결과가 달라지면 안된다**! 그런데 내 코드는 이러한 두 번째 테스트 케이스처럼 들어오는 순서가 순차적인 단계가 아닐 때 잘못된 값을 출력했다!
- 내가 짠 코드에서는  도로 연결 정보를 바로 거리 정보에 계산하여 넣어버렸다. 즉, 데이터를 입력받으면서 계산 및 활용함으로써 **들어오는 정보의 순서에 의존적이게 되었던 것!**
- 즉, **도로 연결 정보와 거리 정보를 분리**했어야 한다는 것!
- 아래에 있는 교재의 예제와 같이 도로 연결 정보를 모두 저장한 뒤, 문제에 명시된 것 처럼 시작 도시부터 차례대로 차근차근 BFS를 이용하여 최소 거리를 찾아 나갔어야 함!

## 교재의 풀이 (이것이 코딩테스트다 with 파이썬)

```python
from collections import deque

# 도시의 개수, 도로의 개수, 거리 정보, 출발 도시 번호
n, m, k, x = map(int, input().split())
graph = [[] for _ in range(n+1)]

# 모든 도로 정보 입력받기
for _ in range(m):
  a, b = map(int, input().split())
  graph[a].append(b)

# 모든 도시에 대한 최단 거리 초기화
distance = [-1] * (n + 1)
distance[x] = 0  # 출발 도시까지의 거리는 0으로 설정

# 너비 우선 탐색(BFS) 수행
q = deque([x])
while q:
  now = q.popleft()
  # 현재 도시에서 이동할 수 있는 모든 도시를 확인
  for next_node in graph[now]:
    # 아직 방문하지 않은 도시라면
    if distance[next_node] == -1:
      # 최단 거리 갱신
      distance[next_node] = distance[now] + 1
      q.append(next_node)

# 최단 거리가 K인 모든 도시의 번호를 오름차순으로 출력
check = False
for i in range(1, n+1):
  if distance[i] == k:
    print(i)
    check = True

# 만약 최단 거리가 K인 도시가 없다면, -1 출력
if check == False:
  print(-1)
```

- 우선 도시의 개수, 도로의 개수, 거리 정보, 출발 도시 번호를 저장한다
- 그리고 for문을 돌면서 모든 도로 정보를 graph라는 2차원 리스트에 저장한다 (이때 인접리스트 형태로 정보가 저장된다)
- 그리고 queue를 활용해 BFS 알고리즘을 사용하며 최단 거리를 갱신한다
- 우선 시작(현재) 도시에서 이동할 수 있는 모든 도시를 확인한다
- 아직 방문하지 않은 도시라면 최단거리로 갱신한다
- 최단거리로 갱신함과 동시에 BFS 알고리즘을 위해 queue에 넣는다
- queue가 빌 때 까지 반복한다
- 모든 최단 거리 계산을 완료했을 때, 거리 정보가 저장된 리스트를 반복문을 통해 돌면서 입력된 거리 정보를 저장하고 있는 도시의 번호를 출력한다
