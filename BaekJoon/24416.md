## 문제

오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

오늘은 *n*의 피보나치 수를 재귀호출과 동적 프로그래밍으로 구하는 알고리즘을 배웠다. 재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자. 아래 의사 코드를 이용하여 *n*의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.

피보나치 수 재귀호출 의사 코드는 다음과 같다.

```
fib(n) {
    if (n = 1 or n = 2)
    then return 1;  # 코드1
    else return (fib(n - 1) + fib(n - 2));
}
```

피보나치 수 동적 프로그래밍 의사 코드는 다음과 같다.

```
fibonacci(n) {
    f[1] <- f[2] <- 1;
    for i <- 3 to n
        f[i] <- f[i - 1] + f[i - 2];  # 코드2
    return f[n];
}
```

## 입력

첫째 줄에 *n*(5 ≤ *n* ≤ 40)이 주어진다.

## 출력

코드1 코드2 실행 횟수를 한 줄에 출력한다.

## 예제 입력 1

```
5

```

## 예제 출력 1

```
5 3

```

## 예제 입력 2

```
30

```

## 예제 출력 2

```
832040 28
```

## 나의 풀이

```python
n = int(input())

fib = [0]  * 41
fib[1] = 1
fib[2] = 1

for i in range(3, n+1):
  fib[i] = fib[i-1] + fib[i-2]

print(fib[n], n-2)
```

- 만약 피보나치 수열을 위해 **재귀함수를 부르고 카운팅하게 되면 시간초과**가 나므로, 직접 카운팅하는 것이 아닌 규칙을 파악하여 DP를 통해 풀어야 한다
- 피보나치 수열은 $f(x) = f(x-1) + f(x-2)$ 라는 규칙을 가지고 있다. 이 수식을 토대로 각 호출 횟수를 리스트에 저장한다. 
이 때, f(1)과 f(2)는 1로 초기화 한다
- n은 3 이상이기 때문에, 3부터 n까지는 앞선 호출횟수들을 참조하여   $f(x) = f(x-1) + f(x-2)$ 규칙에 따라 호출횟수를 리스트에 채워나간다
- 그에 따라 list[n]에는 재귀함수로의 호출횟수를 저장하고 있게 된다.
- DP를 통한 호출 횟수는 $n-2$의 규칙을 갖고 있어서, 이대로 반환한다.
