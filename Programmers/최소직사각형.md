### **문제 설명**

명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

| 명함 번호 | 가로 길이 | 세로 길이 |
| --- | --- | --- |
| 1 | 60 | 50 |
| 2 | 30 | 70 |
| 3 | 60 | 30 |
| 4 | 80 | 40 |

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- sizes의 길이는 1 이상 10,000 이하입니다.
    - sizes의 원소는 [w, h] 형식입니다.
    - w는 명함의 가로 길이를 나타냅니다.
    - h는 명함의 세로 길이를 나타냅니다.
    - w와 h는 1 이상 1,000 이하인 자연수입니다.

---

### 입출력 예

| sizes | result |
| --- | --- |
| [[60, 50], [30, 70], [60, 30], [80, 40]] | 4000 |
| [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]] | 120 |
| [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]] | 133 |

---

### 입출력 예 설명

입출력 예 #1문제 예시와 같습니다.

입출력 예 #2명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.

입출력 예 #3명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.

### 풀이 공유

- **박동연의 풀이 🐯**
    
    **첫 번째 풀이**
    
    ```python
    def solution(sizes):
        for size in sizes:
            max_len, min_len = max(size), min(size)
            size[0] = max_len
            size[1] = min_len
        
        w, h = -1, -1
        for size in sizes:
            if size[0] > w:
                w = size[0]
            if size[1] > h:
                h = size[1]
        
        return w*h
    ```
    
    - 모든 명함을 포함할 수 있으려면 각 가로, 세로 길이의 최대값을 구하여 곱한 면적을 알아야한다
    - 따라서 한쪽 변에는 가장 긴 길이만 두도록 회전하고, 다른 한쪽 변에는 가장 짧은 길이의 명함만 두도록 회전한다
    - 즉, 각 명함(요소) 내에서 최대값과 최소값을 찾는다
    - 그리고 각 최대값들과 최소값들 중에서 최대값을 찾아서 각각을 곱한다
    
    **두 번째 풀이**
    
    ```python
    def solution(sizes):
        
        w, h = -1, -1
        for size in sizes:
            max_len, min_len = max(size), min(size)
            size[0] = max_len
            size[1] = min_len
            
            if size[0] > w:
                w = size[0]
            if size[1] > h:
                h = size[1]
        
        return w*h
    ```
    
    - 첫 번째 코드에서는 각 요소 내 최대값과 최소값을 확인하여 배치하고, 이 중에 최대값을 찾는 과정을 서로 다른 for문을 통해 수행하도록 하였다.
    - 따라서 2O(N)의 시간복잡도를 보였으나, 이를 하나의 for문에서 수행하도록 하여, **O(N)으로 시간복잡도를 줄이도록 하였다.**
    
    **다른 사람의 풀이**
    
    ```python
    def solution(sizes):
        return max(max(x) for x in sizes) * max(min(x) for x in sizes)
    ```
    
    - 근본적인 접근 방식은 동일하나 (각 요소에 따른 최대값을 찾아서 곱하기), 내가 작성한 코드보다 훨씬 간결하게 한 줄로 풀이하였다
    - 우선 for문을 한 줄로 작성하여 리스트 형식으로 원하는 값만 뽑아 반환하였고, min() 함수와 max()함수를 사용해 뽑아낸 값을 바로 곱해 반환함으로써 별도의 데이터 저장을 위한 메모리를 사용하지 않았다
    - 본 코드의 **시간복잡도는 2O(N)**이지만, **코드가 매우 간결하고 변수 저장을 위한 메모리를 절약**하였다는 것에서 이점이 있다
