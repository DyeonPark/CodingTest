### **문제 설명**

n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

- `1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3`

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

### 입출력 예

| numbers | target | return |
| --- | --- | --- |
| [1, 1, 1, 1, 1] | 3 | 5 |
| [4, 1, 2, 1] | 4 | 2 |

### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

`+4+1-2+1 = 4
+4-1+2-1 = 4`

- 총 2가지 방법이 있으므로, 2를 return 합니다.

### 🖥 내가 작성한 코드

```python
from itertools import combinations

def solution(numbers, target):
    answer = 0
    
    for num in range(1, len(numbers) + 1):
        for selected_list in combinations(numbers, num):  # 모든 comb 조합 구하기
            
            tmp = numbers.copy()  # 원본 리스트 복사
            for i in selected_list:  # 원본 리스트에서 comb 요소 제외
                tmp.remove(i)
                
            if sum(tmp) - sum(selected_list) == target:  # target과 동일한지 판단
                answer +=1 
            
    return answer
```

- **DFS/BFS로 분류**되어있던 문제지만, 도저히 DFS를 이용해서 풀 방안이 생각이 나지 않아서 완**전탐색이자 Brute-Force 방법**을 사용하여 풀었다
- 우선 기본적인 사고 방안은 다음과 같다
(1) 입력받은 리스트에서 **모든 combinations 조합**을 구한다 → itertools 라이브러리 사용
(2) 구한 **combinations 조합의 리스트의 합**을 구해서 **이를 제외한 원본 리스트의 합에서 빼자!**
(3) 그리고 **target과 동일한지 판단**  → answer(counting용 변수)를 1 더하기
- 그리고 이를 차례로 구현한 코드가 위와 같다

### ❓ 생각해보면 좋을 것

- 그리고 문제 풀이 과정에서 수의 개념에서 몇 가지 혼란스러웠던 것이 있다

<aside>
👋 **”+1이 3개 있는 묶음에서 +1을 하나 빼는 것”**과
**”+1이 3개 있는 묶음에서 하나를 -1로 교체하는 것”**은 **다르다**는 것이다!

</aside>

- 어떻게보면 당연한 것이지만, 코테 풀이과정을 생각하다 보면 혼란스러워지기 쉬운 것 같다
- 아무래도 위 문제에서 적용해서 생각해본다면
” 원본 리스트에서 combinations의 요소를 뺀 다음 합산 값이 target과 동일한지 확인하면 되지 않나? “ 라고 생각하기 쉬운 것 같기 때문이다.
- 하지만 +1을 하나 빼는 것은 +1 → 0 으로 **-1이 감소**하는 것이고
-1로 교체하는 것은 +1 → -1로 **-2가 감소**하는 것이다.
- 따라서 프로그래밍적 관점에서 리스트에서 요소를 더하고 빼는 것에 매몰되다가 수의 기본적인 개념을 혼동하지 않도록 주의하는 것이 좋을 것 같다

### 다른 사람의 풀이 (1)

```python
def solution(numbers, target):
    if not numbers and target == 0 :
        return 1
    elif not numbers:
        return 0
    else:
        return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0])
```

- 재귀 함수를 이용하여 간단하게 문제를 DFS 알고리즘 방식으로 풀이했다..! 놀라운 코드.. 😮
- 대략적으로 재귀함수를 이용한 분할정복을 통해 문제를 풀어나간 것으로 보이는데, 코드가 100% 세세하게 이해가지는 않는다..

### 다른 사람의 풀이 (2)

```python
from itertools import product
def solution(numbers, target):
    l = [(x, -x) for x in numbers]
    s = list(map(sum, product(*l)))
    return s.count(target)
```

- 위 코드에서는  **완전탐색**의 방식을 사용하여 문제를 풀었다
- 우선 solution 함수의 첫 번재 줄에서는 입력 리스트 number을 리스트 컴프리헨션을 통해 각 요소의 양수/음수를 튜플로 묶어 새로운 리스트 l 로 생성한다
예) [1, 2, 3] → [(1, -1), (2, -2), (3, -3)]
- itertools 라이브러리에 있는 **product 함수**를 사용해 리스트 l을 내에 있는 모든 요소의 조합의 합을 구한다. 이때 *l로 쓰는 이유는 l 안의 원소를 하나씩 풀어야 product가 가능해지기 때문이다.
- 내가 풀이한 방법과 유사하기는 하나, 본 방식이 for 문을 최소한으로 사용함에 따라 시간복잡도가 훨씬 작고, 코드가 간결하고 가독성이 좋다는 장점이 있다!


👋 .. 뭔가 .. 꼭 DFS/BFS 로 분류되어 있다고 해서, 그 **유형의 틀에 맞춰서 풀어야 한다는 생각을 버리는게 좋을 것 같다!** 출제자의 의도를 파악해서 풀이하는 것도 좋지만, 코테라는게 어떻게든 **창의적인 나만의 방식으로도 통과**만 하면 되는거니까..!
